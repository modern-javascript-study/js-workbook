# 5-1 원시값의 메서드

## 원시값의 메서드
자바스크립트는 원시값(문자열, 숫자 등)을 마치 객체처럼 다룰 수 있게 해준다. 
  원시값에도 객체에서처럼 메서드를 호출 할 수 있다. 
  
  원시값과 객체의 차이 
  원시값
  - 원시형 값이다. 
  - 원시형의 종류는 문자(String), 숫자(number), bigint, 불린(boolean), 심볼(symbol), null, undefiend형 으로 총 일곱 가지 이다. 
  
  객체
  - 프로퍼티에 다양한 종류의 값을 저장할 수 있다. 
  - {name: "John", age: 30} 와 같이 대괄호 {}를 사용해 만들 수 있다. 
  
  객체의 장점 중 하나는 함수를 프로퍼티로 저장할 수 있다는 것이다. 
  ``` jsx
  let johm ={
    name: "John", 
    sayHi: function() {
      alert("친구야 반갑다~");
      }
    };
john.sayHi(); //친구야 반갑다. 
```

자바스크립트는 날짜, 오류, HTML요소 등을 다룰 수 있게 해주는 다양한 내장 객체를 제공한다. 
이 객체들은 고유한 프로퍼티와 메서드를 가진다. 
  
하지만, 이런 긴으을 사용하면 시스템 자원이 많이 소모된다는 단점 존재

객체는 원시값 보다 "무겁고", 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문에



## 원시값을 객체 처럼 사용하기 
- 문자열이나 숫자와 같으 원시값을 다루어야 하는 작업이 많은데, 메서드를 사용하면 작업을 수월하게 할 수 있지 않을까? 근데 원시값은 가능한 한 빠르고 가벼워야 하는데...
  
===> 해결책
1. 원시값은 원시값 그대로 남겨둬 단일 값 형태를 유지
2. 문자열, 숫자, 불린, 심볼 의 메서드와 프로퍼티에 접근할 수 있도록 언어차원에서 허용
3. 이를 가능하게 하기 위해, 원시갑이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, "원시 래퍼 객체"를 만들어준다. 이 객체는 곧 삭제된다. 
  
  ``` jsx
  let str = "Hello";
  alert(str.toUpperCase()); //HELLO
```

위에 코드에서 일어나는 과정
1. 문자열 str은 원시값이므로 원시값의 프로퍼티(toUpperCase)에 접근하는 순간 특별한 객체가 만들어집니다. 
  이 객체는 문자열의 값을 알고 있고, toUpperCase()와 같은 유용한 메서드를 가지고 있습니다.
2. 메서드가 실행되고, 새로운 문자열이 반환됩니다(alert 창에 이 문자열이 출력됩니다).
3. 특별한 객체는 파괴되고, 원시값 str만 남습니다.
  
이런 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있다. 
  
자바스크립트 엔진은 위 프로세스의 최적화에 많은 신경을 쓴다. 
원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성한 것 처럼 동작하게끔 한다. 
  
* null/undefined는 메서드가 없다. 
  ``` jsx
  alert(null.test); //error
  ```
  
  
  <hr/>
  
# 숫자형
    
## 숫자를 입력하는 다양한 방법
``` jsx
let billion = 10000000;
```
 이렇게 많은 0을 사용하면 잘못 입력하기 쉽다.
그렇기에 10억을 나타낼때 '1bn'을 사용하고 73억을 나타낼땐, '7.3bn'을 사용한다. 
  
``` jsx
let billion = 1e9;  // 10억, 1과 9개의 0

alert( 7.3e9 );  // 73억 (7,300,000,000)
```

'e'는 e 왼쪽의 수에 e 오른쪽에 있는 수 만큼의 10의 거듭제곱을 곱하는 효과가 있다. 
  
  ``` 
  let3 = 1 * 1000
  1.23e6 = 1.23 * 1000000
  ```
  
  작은 숫자를 표현할 때도 'e'를 사용할 수 있다. 
  ``` jsx
  let ms = 1e - 6; // 1에서 왼족으로 6번 소수점 이동
  ```
  
  'e' 우측에 음수가 있으면, 이 음수의 절댓값 만틈 10 을 거듭제곱한 수로 나누는 것을 의미한다. 
  
  ``` jsx
  // 10을 세 번 거듭제곱한 수로 나눔
  1e-3 = 1 / 1000 (0.001)
  
 // 10을 여섯번 거듭 제곱한 수로 나눔
 1.23e-6  = 1.23 / 1000000(=0.00000123)
 ```
 
 ## 16진수, 2진수, 8진수
 
 16진수 표현
 0x 사용
 
 ``` jsx
 alert(0xff); //255
 alert(0xFF);//255 (대. 소문자를 가리지 않으므로 둘 다 같은 값을 나타낸다)
 ```
 
 2진수 8진수는 아주 드물게 쓰이긴 하지만, 겁두사 0b와 0o를 사용해 간단히 나타낼 수 있다. 
 
 let a = 0b11111111;// 255의 2진수 
 let b = 0o377; // 255의 8진수
 
 alert(a == b); // true
 
 ```
 
 ## toString(base)
 num.toString(base)메서드는 base 진법으로 num을 표현한 후, 이를 문자형으로 변환해 반환한다. 
 ```jsx
 let num = 255;
 
 alert(num.toString(16)); // ff
 alert(num.toString(2); // 1111111
 ```
 
base는 2에서 36까지 쓸 수 있는데 기본 값은 10이다. 
  

## 어림수 구하기 
- Math.floor
소수점 첫째자리 내림(버림)
3.1 은 3, -1.1 은 -2가 된다. 

- Math.ceil 
소수점 첫째자리 에서 올림 
3.1 은 4, -1.1 은 -1이 된다. 

- Math.round
소수점 첫째 자리에서 반올림 3.1은 3, 3.6은 4, -1.1은 -1이 된다. 

- Math.trunc
소수부를 무시 
3.1은 3, -1.1 은 1

만약 1.2345가 있는데 소수점 두번재 자릿수까미나 남겨 1.23을 만들고 싶으면 어떻하기 
1. 곱하기와 나누기 
``jsx
let num = 1.23456;

alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
```

2. toFixed(n)메서드 사용
``` jsx
let num = 12.34;
alert(num.toFixed(1)); //"12.3;
```
toFixed는 Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림해줍니다.

``` jsx
let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
```
toFixed를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것입니다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가됩니다.

``` jsx
let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", 소수부의 길이를 5로 만들기 위해 0이 추가
```

##  부정확한 tnt
숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용됩니다.

그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리됩니다.

``` jsx
alert( 1e500 ); // Infinity
```

정밀도 손실

``` jsx
alert( 0.1 + 0.2 == 0.3 ); // false
```

왜 false일까?
``` jsx
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

해결 방법
toFixed(n)메서드 사용해 어림 수 만들기
하지만 이때 주의 해야할점은 toFixed()메서드는 문자열을 반환하므로 숫자형으로 변환시켜야 한다. 

``` jsx
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
``` 


## isNaN과 isFinite
Infinity와 -Infinity – 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
NaN – 에러를 나타내는 값

두 특수 숫자는 숫자형에 속하지만 ‘정상적인’ 숫자는 아니기 때문에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재함

isNaN(Value) - 인수를 숫자로 변환한 다음 NaN인지 테스트함 
```jsx
alert(isNaN(NaN)); //true
alert(isNaN("str"); // true
```

왜 ===NaN으로 비교 하지 않을까?
왜냐하면 NaN은 NaN 자기 자신을 포함하여 그 어떤 값과도 갇지 않다는 독특한 점을 가지고 있기 때문이다. 
``` jsx
alert(NaN === NaN) ; false

```

isFinite(vlaue) 
인수를 숫자로 변환하고 변환한 숫자가 NaN/Infinty/-Infinity가 아닌 일반 숫자인 경우 true를 반환한다. 
``` jsx
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, NaN이기 때문입니다.
alert( isFinite(Infinity) ); // false, Infinity이기 때문입니다.
```

isFinite는 문자열이 일반 숫자인지 검증하는데 사용되곤 한다. 
``` jsx
let num - +prompt("숫자를 입력하세여.", '');

// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity 를 입력하면 false가 출력된다. 
alert( isFinite(num) );
```

## parseInt와 parseFloat
단항 덧셈 연산자 + 또는 Number() 를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 엄격한다. 
그렇기에 피연산자가 숫자가 아니면 형 변환이 실패한다. 

``` jsx
alert( +"100px" ); // NaN
```
엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때입니다.

그런데 실무에선 CSS 등에서 '100px', '12pt'와 같이 숫자와 단위를 함께 쓰는 경우가 흔합니다. 대다수 국가에서 '19€'처럼 금액 뒤에 통화 기호를 붙여 표시하기도 하죠. 숫자만 추출하는 방법이 필요해 보이네요.

내장 함수 parseInt와 parseFloat는 이런 경우를 위해 만들어졌습니다.

두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽습니다’. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환하죠. parseInt는 정수, parseFloat는 부동 소수점 숫자를 반환합니다.

``` jsx
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.
alert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.
```

parseInt와 parseFloat가 Nan을 반환할 때
-> 읽을 숫자가 없을 때
``` jsx
alert(parseInt('a123'); //NaN, a는 숫자가 아니므로 숫자를 읽는게 중지된다. 
```



## 기타 수학 함수 

Math.random();
0과 1 사이의 난수를 반환한다. (1은 제외)
``` jsx
alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (무작위 수)
```

Math.max(a, b, c ...)/ Math.min(a, b, c ...)
인수 중 최대. 최솟값을 반환한다. 
``` jsx
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
```

Math.pow(n, power)
n을 power번 거듭제곱한 값을 반환한다.
``` jsx
alert(Math.pow(2, 10); // 2의 10 제곱 = 1024
```

